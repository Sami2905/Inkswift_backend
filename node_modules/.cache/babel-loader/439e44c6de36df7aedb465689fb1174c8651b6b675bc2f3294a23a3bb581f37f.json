{"ast":null,"code":"import { PDFDocument, PDFImage } from 'pdf-lib';\n\n/**\r\n * Embeds signature images into PDF with proper transformation matrix\r\n * @param {ArrayBuffer} pdfBuffer - Original PDF buffer\r\n * @param {Array} signatureFields - Array of signature field objects with position, size, rotation\r\n * @returns {Promise<ArrayBuffer>} - Modified PDF buffer\r\n */\nexport const embedSignaturesWithTransform = async (pdfBuffer, signatureFields) => {\n  try {\n    // Load the PDF document\n    const pdfDoc = await PDFDocument.load(pdfBuffer);\n\n    // Process each signature field\n    for (const field of signatureFields) {\n      var _field$signature;\n      if (!((_field$signature = field.signature) !== null && _field$signature !== void 0 && _field$signature.data) || !field.page) continue;\n\n      // Get the page (0-indexed)\n      const page = pdfDoc.getPage(field.page - 1);\n      if (!page) continue;\n\n      // Convert base64 image to Uint8Array\n      const imageData = field.signature.data;\n      let imageBytes;\n      if (imageData.startsWith('data:image/')) {\n        // Handle base64 data URL\n        const base64Data = imageData.split(',')[1];\n        imageBytes = Uint8Array.from(atob(base64Data), c => c.charCodeAt(0));\n      } else {\n        // Handle raw base64 string\n        imageBytes = Uint8Array.from(atob(imageData), c => c.charCodeAt(0));\n      }\n\n      // Embed the image\n      let pdfImage;\n      if (imageData.includes('image/png')) {\n        pdfImage = await pdfDoc.embedPng(imageBytes);\n      } else if (imageData.includes('image/jpeg') || imageData.includes('image/jpg')) {\n        pdfImage = await pdfDoc.embedJpg(imageBytes);\n      } else {\n        console.warn('Unsupported image format:', imageData);\n        continue;\n      }\n\n      // Get page dimensions\n      const {\n        width: pageWidth,\n        height: pageHeight\n      } = page.getSize();\n\n      // Calculate position (PDF coordinates start from bottom-left)\n      const x = field.x;\n      const y = pageHeight - field.y - field.height; // Flip Y coordinate\n\n      // Calculate transformation matrix for rotation and scaling\n      const rotationRad = (field.rotation || 0) * (Math.PI / 180);\n      const cos = Math.cos(rotationRad);\n      const sin = Math.sin(rotationRad);\n\n      // Calculate center point for rotation\n      const centerX = x + field.width / 2;\n      const centerY = y + field.height / 2;\n\n      // Build transformation matrix\n      // [a b c d e f] where:\n      // a = scaleX * cos(rotation)\n      // b = scaleX * sin(rotation)\n      // c = -scaleY * sin(rotation)\n      // d = scaleY * cos(rotation)\n      // e = translateX\n      // f = translateY\n\n      const scaleX = field.width / pdfImage.width;\n      const scaleY = field.height / pdfImage.height;\n      const matrix = [scaleX * cos,\n      // a\n      scaleX * sin,\n      // b\n      -scaleY * sin,\n      // c\n      scaleY * cos,\n      // d\n      centerX - (centerX * cos - centerY * sin),\n      // e (translation X)\n      centerY - (centerX * sin + centerY * cos) // f (translation Y)\n      ];\n\n      // Draw the image with transformation\n      page.drawImage(pdfImage, {\n        x: 0,\n        y: 0,\n        width: pdfImage.width,\n        height: pdfImage.height,\n        transform: matrix\n      });\n    }\n\n    // Save the modified PDF\n    const modifiedPdfBytes = await pdfDoc.save();\n    return modifiedPdfBytes;\n  } catch (error) {\n    console.error('Error embedding signatures:', error);\n    throw new Error('Failed to embed signatures into PDF');\n  }\n};\n\n/**\r\n * Alternative method using simpler transformation for better compatibility\r\n */\nexport const embedSignaturesSimple = async (pdfBuffer, signatureFields) => {\n  try {\n    const pdfDoc = await PDFDocument.load(pdfBuffer);\n    for (const field of signatureFields) {\n      var _field$signature2;\n      if (!((_field$signature2 = field.signature) !== null && _field$signature2 !== void 0 && _field$signature2.data) || !field.page) continue;\n      const page = pdfDoc.getPage(field.page - 1);\n      if (!page) continue;\n\n      // Convert image data\n      const imageData = field.signature.data;\n      let imageBytes;\n      if (imageData.startsWith('data:image/')) {\n        const base64Data = imageData.split(',')[1];\n        imageBytes = Uint8Array.from(atob(base64Data), c => c.charCodeAt(0));\n      } else {\n        imageBytes = Uint8Array.from(atob(imageData), c => c.charCodeAt(0));\n      }\n\n      // Embed image\n      let pdfImage;\n      if (imageData.includes('image/png')) {\n        pdfImage = await pdfDoc.embedPng(imageBytes);\n      } else if (imageData.includes('image/jpeg') || imageData.includes('image/jpg')) {\n        pdfImage = await pdfDoc.embedJpg(imageBytes);\n      } else {\n        continue;\n      }\n      const {\n        width: pageWidth,\n        height: pageHeight\n      } = page.getSize();\n\n      // Calculate position\n      const x = field.x;\n      const y = pageHeight - field.y - field.height;\n\n      // Draw with rotation and scaling\n      page.drawImage(pdfImage, {\n        x,\n        y,\n        width: field.width,\n        height: field.height,\n        rotate: {\n          angle: field.rotation || 0,\n          type: 'degrees'\n        }\n      });\n    }\n    const modifiedPdfBytes = await pdfDoc.save();\n    return modifiedPdfBytes;\n  } catch (error) {\n    console.error('Error embedding signatures (simple method):', error);\n    throw new Error('Failed to embed signatures into PDF');\n  }\n};\n\n/**\r\n * Creates a flattened signature image with proper styling\r\n */\nexport const createFlattenedSignatureImage = async (signatureData, width, height, rotation = 0) => {\n  return new Promise(resolve => {\n    const canvas = document.createElement('canvas');\n    const ctx = canvas.getContext('2d');\n\n    // Set canvas size\n    canvas.width = width;\n    canvas.height = height;\n\n    // Create image\n    const img = new Image();\n    img.onload = () => {\n      // Clear canvas\n      ctx.clearRect(0, 0, width, height);\n\n      // Apply transformations\n      ctx.save();\n      ctx.translate(width / 2, height / 2);\n      ctx.rotate(rotation * Math.PI / 180);\n      ctx.translate(-width / 2, -height / 2);\n\n      // Draw image with proper scaling\n      const scaleX = width / img.width;\n      const scaleY = height / img.height;\n      const scale = Math.min(scaleX, scaleY);\n      const scaledWidth = img.width * scale;\n      const scaledHeight = img.height * scale;\n      const offsetX = (width - scaledWidth) / 2;\n      const offsetY = (height - scaledHeight) / 2;\n\n      // Apply subtle shadow for embedded look\n      ctx.shadowColor = 'rgba(0, 0, 0, 0.1)';\n      ctx.shadowBlur = 2;\n      ctx.shadowOffsetX = 1;\n      ctx.shadowOffsetY = 1;\n      ctx.drawImage(img, offsetX, offsetY, scaledWidth, scaledHeight);\n      ctx.restore();\n\n      // Convert to base64\n      const flattenedData = canvas.toDataURL('image/png');\n      resolve(flattenedData);\n    };\n    img.src = signatureData;\n  });\n};","map":{"version":3,"names":["PDFDocument","PDFImage","embedSignaturesWithTransform","pdfBuffer","signatureFields","pdfDoc","load","field","_field$signature","signature","data","page","getPage","imageData","imageBytes","startsWith","base64Data","split","Uint8Array","from","atob","c","charCodeAt","pdfImage","includes","embedPng","embedJpg","console","warn","width","pageWidth","height","pageHeight","getSize","x","y","rotationRad","rotation","Math","PI","cos","sin","centerX","centerY","scaleX","scaleY","matrix","drawImage","transform","modifiedPdfBytes","save","error","Error","embedSignaturesSimple","_field$signature2","rotate","angle","type","createFlattenedSignatureImage","signatureData","Promise","resolve","canvas","document","createElement","ctx","getContext","img","Image","onload","clearRect","translate","scale","min","scaledWidth","scaledHeight","offsetX","offsetY","shadowColor","shadowBlur","shadowOffsetX","shadowOffsetY","restore","flattenedData","toDataURL","src"],"sources":["D:/Doc Sign/client/src/utils/pdfEmbedWithTransform.js"],"sourcesContent":["import { PDFDocument, PDFImage } from 'pdf-lib';\r\n\r\n/**\r\n * Embeds signature images into PDF with proper transformation matrix\r\n * @param {ArrayBuffer} pdfBuffer - Original PDF buffer\r\n * @param {Array} signatureFields - Array of signature field objects with position, size, rotation\r\n * @returns {Promise<ArrayBuffer>} - Modified PDF buffer\r\n */\r\nexport const embedSignaturesWithTransform = async (pdfBuffer, signatureFields) => {\r\n  try {\r\n    // Load the PDF document\r\n    const pdfDoc = await PDFDocument.load(pdfBuffer);\r\n    \r\n    // Process each signature field\r\n    for (const field of signatureFields) {\r\n      if (!field.signature?.data || !field.page) continue;\r\n      \r\n      // Get the page (0-indexed)\r\n      const page = pdfDoc.getPage(field.page - 1);\r\n      if (!page) continue;\r\n      \r\n      // Convert base64 image to Uint8Array\r\n      const imageData = field.signature.data;\r\n      let imageBytes;\r\n      \r\n      if (imageData.startsWith('data:image/')) {\r\n        // Handle base64 data URL\r\n        const base64Data = imageData.split(',')[1];\r\n        imageBytes = Uint8Array.from(atob(base64Data), c => c.charCodeAt(0));\r\n      } else {\r\n        // Handle raw base64 string\r\n        imageBytes = Uint8Array.from(atob(imageData), c => c.charCodeAt(0));\r\n      }\r\n      \r\n      // Embed the image\r\n      let pdfImage;\r\n      if (imageData.includes('image/png')) {\r\n        pdfImage = await pdfDoc.embedPng(imageBytes);\r\n      } else if (imageData.includes('image/jpeg') || imageData.includes('image/jpg')) {\r\n        pdfImage = await pdfDoc.embedJpg(imageBytes);\r\n      } else {\r\n        console.warn('Unsupported image format:', imageData);\r\n        continue;\r\n      }\r\n      \r\n      // Get page dimensions\r\n      const { width: pageWidth, height: pageHeight } = page.getSize();\r\n      \r\n      // Calculate position (PDF coordinates start from bottom-left)\r\n      const x = field.x;\r\n      const y = pageHeight - field.y - field.height; // Flip Y coordinate\r\n      \r\n      // Calculate transformation matrix for rotation and scaling\r\n      const rotationRad = (field.rotation || 0) * (Math.PI / 180);\r\n      const cos = Math.cos(rotationRad);\r\n      const sin = Math.sin(rotationRad);\r\n      \r\n      // Calculate center point for rotation\r\n      const centerX = x + field.width / 2;\r\n      const centerY = y + field.height / 2;\r\n      \r\n      // Build transformation matrix\r\n      // [a b c d e f] where:\r\n      // a = scaleX * cos(rotation)\r\n      // b = scaleX * sin(rotation)\r\n      // c = -scaleY * sin(rotation)\r\n      // d = scaleY * cos(rotation)\r\n      // e = translateX\r\n      // f = translateY\r\n      \r\n      const scaleX = field.width / pdfImage.width;\r\n      const scaleY = field.height / pdfImage.height;\r\n      \r\n      const matrix = [\r\n        scaleX * cos,           // a\r\n        scaleX * sin,           // b\r\n        -scaleY * sin,          // c\r\n        scaleY * cos,           // d\r\n        centerX - (centerX * cos - centerY * sin), // e (translation X)\r\n        centerY - (centerX * sin + centerY * cos)  // f (translation Y)\r\n      ];\r\n      \r\n      // Draw the image with transformation\r\n      page.drawImage(pdfImage, {\r\n        x: 0,\r\n        y: 0,\r\n        width: pdfImage.width,\r\n        height: pdfImage.height,\r\n        transform: matrix\r\n      });\r\n    }\r\n    \r\n    // Save the modified PDF\r\n    const modifiedPdfBytes = await pdfDoc.save();\r\n    return modifiedPdfBytes;\r\n    \r\n  } catch (error) {\r\n    console.error('Error embedding signatures:', error);\r\n    throw new Error('Failed to embed signatures into PDF');\r\n  }\r\n};\r\n\r\n/**\r\n * Alternative method using simpler transformation for better compatibility\r\n */\r\nexport const embedSignaturesSimple = async (pdfBuffer, signatureFields) => {\r\n  try {\r\n    const pdfDoc = await PDFDocument.load(pdfBuffer);\r\n    \r\n    for (const field of signatureFields) {\r\n      if (!field.signature?.data || !field.page) continue;\r\n      \r\n      const page = pdfDoc.getPage(field.page - 1);\r\n      if (!page) continue;\r\n      \r\n      // Convert image data\r\n      const imageData = field.signature.data;\r\n      let imageBytes;\r\n      \r\n      if (imageData.startsWith('data:image/')) {\r\n        const base64Data = imageData.split(',')[1];\r\n        imageBytes = Uint8Array.from(atob(base64Data), c => c.charCodeAt(0));\r\n      } else {\r\n        imageBytes = Uint8Array.from(atob(imageData), c => c.charCodeAt(0));\r\n      }\r\n      \r\n      // Embed image\r\n      let pdfImage;\r\n      if (imageData.includes('image/png')) {\r\n        pdfImage = await pdfDoc.embedPng(imageBytes);\r\n      } else if (imageData.includes('image/jpeg') || imageData.includes('image/jpg')) {\r\n        pdfImage = await pdfDoc.embedJpg(imageBytes);\r\n      } else {\r\n        continue;\r\n      }\r\n      \r\n      const { width: pageWidth, height: pageHeight } = page.getSize();\r\n      \r\n      // Calculate position\r\n      const x = field.x;\r\n      const y = pageHeight - field.y - field.height;\r\n      \r\n      // Draw with rotation and scaling\r\n      page.drawImage(pdfImage, {\r\n        x,\r\n        y,\r\n        width: field.width,\r\n        height: field.height,\r\n        rotate: { angle: field.rotation || 0, type: 'degrees' }\r\n      });\r\n    }\r\n    \r\n    const modifiedPdfBytes = await pdfDoc.save();\r\n    return modifiedPdfBytes;\r\n    \r\n  } catch (error) {\r\n    console.error('Error embedding signatures (simple method):', error);\r\n    throw new Error('Failed to embed signatures into PDF');\r\n  }\r\n};\r\n\r\n/**\r\n * Creates a flattened signature image with proper styling\r\n */\r\nexport const createFlattenedSignatureImage = async (signatureData, width, height, rotation = 0) => {\r\n  return new Promise((resolve) => {\r\n    const canvas = document.createElement('canvas');\r\n    const ctx = canvas.getContext('2d');\r\n    \r\n    // Set canvas size\r\n    canvas.width = width;\r\n    canvas.height = height;\r\n    \r\n    // Create image\r\n    const img = new Image();\r\n    img.onload = () => {\r\n      // Clear canvas\r\n      ctx.clearRect(0, 0, width, height);\r\n      \r\n      // Apply transformations\r\n      ctx.save();\r\n      ctx.translate(width / 2, height / 2);\r\n      ctx.rotate((rotation * Math.PI) / 180);\r\n      ctx.translate(-width / 2, -height / 2);\r\n      \r\n      // Draw image with proper scaling\r\n      const scaleX = width / img.width;\r\n      const scaleY = height / img.height;\r\n      const scale = Math.min(scaleX, scaleY);\r\n      \r\n      const scaledWidth = img.width * scale;\r\n      const scaledHeight = img.height * scale;\r\n      const offsetX = (width - scaledWidth) / 2;\r\n      const offsetY = (height - scaledHeight) / 2;\r\n      \r\n      // Apply subtle shadow for embedded look\r\n      ctx.shadowColor = 'rgba(0, 0, 0, 0.1)';\r\n      ctx.shadowBlur = 2;\r\n      ctx.shadowOffsetX = 1;\r\n      ctx.shadowOffsetY = 1;\r\n      \r\n      ctx.drawImage(img, offsetX, offsetY, scaledWidth, scaledHeight);\r\n      ctx.restore();\r\n      \r\n      // Convert to base64\r\n      const flattenedData = canvas.toDataURL('image/png');\r\n      resolve(flattenedData);\r\n    };\r\n    \r\n    img.src = signatureData;\r\n  });\r\n}; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}