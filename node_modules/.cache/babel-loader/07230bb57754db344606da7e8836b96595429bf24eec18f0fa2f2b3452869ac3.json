{"ast":null,"code":"/*!\n * Signature Pad v5.0.10 | https://github.com/szimek/signature_pad\n * (c) 2025 Szymon Nowak | Released under the MIT license\n */\n\nclass Point {\n  constructor(x, y, pressure, time) {\n    if (isNaN(x) || isNaN(y)) {\n      throw new Error(\"Point is invalid: (\".concat(x, \", \").concat(y, \")\"));\n    }\n    this.x = +x;\n    this.y = +y;\n    this.pressure = pressure || 0;\n    this.time = time || Date.now();\n  }\n  distanceTo(start) {\n    return Math.sqrt(Math.pow(this.x - start.x, 2) + Math.pow(this.y - start.y, 2));\n  }\n  equals(other) {\n    return this.x === other.x && this.y === other.y && this.pressure === other.pressure && this.time === other.time;\n  }\n  velocityFrom(start) {\n    return this.time !== start.time ? this.distanceTo(start) / (this.time - start.time) : 0;\n  }\n}\nclass Bezier {\n  static fromPoints(points, widths) {\n    const c2 = this.calculateControlPoints(points[0], points[1], points[2]).c2;\n    const c3 = this.calculateControlPoints(points[1], points[2], points[3]).c1;\n    return new Bezier(points[1], c2, c3, points[2], widths.start, widths.end);\n  }\n  static calculateControlPoints(s1, s2, s3) {\n    const dx1 = s1.x - s2.x;\n    const dy1 = s1.y - s2.y;\n    const dx2 = s2.x - s3.x;\n    const dy2 = s2.y - s3.y;\n    const m1 = {\n      x: (s1.x + s2.x) / 2.0,\n      y: (s1.y + s2.y) / 2.0\n    };\n    const m2 = {\n      x: (s2.x + s3.x) / 2.0,\n      y: (s2.y + s3.y) / 2.0\n    };\n    const l1 = Math.sqrt(dx1 * dx1 + dy1 * dy1);\n    const l2 = Math.sqrt(dx2 * dx2 + dy2 * dy2);\n    const dxm = m1.x - m2.x;\n    const dym = m1.y - m2.y;\n    const k = l1 + l2 == 0 ? 0 : l2 / (l1 + l2);\n    const cm = {\n      x: m2.x + dxm * k,\n      y: m2.y + dym * k\n    };\n    const tx = s2.x - cm.x;\n    const ty = s2.y - cm.y;\n    return {\n      c1: new Point(m1.x + tx, m1.y + ty),\n      c2: new Point(m2.x + tx, m2.y + ty)\n    };\n  }\n  constructor(startPoint, control2, control1, endPoint, startWidth, endWidth) {\n    this.startPoint = startPoint;\n    this.control2 = control2;\n    this.control1 = control1;\n    this.endPoint = endPoint;\n    this.startWidth = startWidth;\n    this.endWidth = endWidth;\n  }\n  length() {\n    const steps = 10;\n    let length = 0;\n    let px;\n    let py;\n    for (let i = 0; i <= steps; i += 1) {\n      const t = i / steps;\n      const cx = this.point(t, this.startPoint.x, this.control1.x, this.control2.x, this.endPoint.x);\n      const cy = this.point(t, this.startPoint.y, this.control1.y, this.control2.y, this.endPoint.y);\n      if (i > 0) {\n        const xdiff = cx - px;\n        const ydiff = cy - py;\n        length += Math.sqrt(xdiff * xdiff + ydiff * ydiff);\n      }\n      px = cx;\n      py = cy;\n    }\n    return length;\n  }\n  point(t, start, c1, c2, end) {\n    return start * (1.0 - t) * (1.0 - t) * (1.0 - t) + 3.0 * c1 * (1.0 - t) * (1.0 - t) * t + 3.0 * c2 * (1.0 - t) * t * t + end * t * t * t;\n  }\n}\nclass SignatureEventTarget {\n  constructor() {\n    try {\n      this._et = new EventTarget();\n    } catch (_a) {\n      this._et = document;\n    }\n  }\n  addEventListener(type, listener, options) {\n    this._et.addEventListener(type, listener, options);\n  }\n  dispatchEvent(event) {\n    return this._et.dispatchEvent(event);\n  }\n  removeEventListener(type, callback, options) {\n    this._et.removeEventListener(type, callback, options);\n  }\n}\nfunction throttle(fn) {\n  let wait = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 250;\n  let previous = 0;\n  let timeout = null;\n  let result;\n  let storedContext;\n  let storedArgs;\n  const later = () => {\n    previous = Date.now();\n    timeout = null;\n    result = fn.apply(storedContext, storedArgs);\n    if (!timeout) {\n      storedContext = null;\n      storedArgs = [];\n    }\n  };\n  return function wrapper() {\n    const now = Date.now();\n    const remaining = wait - (now - previous);\n    storedContext = this;\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    storedArgs = args;\n    if (remaining <= 0 || remaining > wait) {\n      if (timeout) {\n        clearTimeout(timeout);\n        timeout = null;\n      }\n      previous = now;\n      result = fn.apply(storedContext, storedArgs);\n      if (!timeout) {\n        storedContext = null;\n        storedArgs = [];\n      }\n    } else if (!timeout) {\n      timeout = window.setTimeout(later, remaining);\n    }\n    return result;\n  };\n}\nclass SignaturePad extends SignatureEventTarget {\n  constructor(canvas) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var _a, _b, _c;\n    super();\n    this.canvas = canvas;\n    this._drawingStroke = false;\n    this._isEmpty = true;\n    this._lastPoints = [];\n    this._data = [];\n    this._lastVelocity = 0;\n    this._lastWidth = 0;\n    this.velocityFilterWeight = options.velocityFilterWeight || 0.7;\n    this.minWidth = options.minWidth || 0.5;\n    this.maxWidth = options.maxWidth || 2.5;\n    this.throttle = (_a = options.throttle) !== null && _a !== void 0 ? _a : 16;\n    this.minDistance = (_b = options.minDistance) !== null && _b !== void 0 ? _b : 5;\n    this.dotSize = options.dotSize || 0;\n    this.penColor = options.penColor || 'black';\n    this.backgroundColor = options.backgroundColor || 'rgba(0,0,0,0)';\n    this.compositeOperation = options.compositeOperation || 'source-over';\n    this.canvasContextOptions = (_c = options.canvasContextOptions) !== null && _c !== void 0 ? _c : {};\n    this._strokeMoveUpdate = this.throttle ? throttle(SignaturePad.prototype._strokeUpdate, this.throttle) : SignaturePad.prototype._strokeUpdate;\n    this._handleMouseDown = this._handleMouseDown.bind(this);\n    this._handleMouseMove = this._handleMouseMove.bind(this);\n    this._handleMouseUp = this._handleMouseUp.bind(this);\n    this._handleTouchStart = this._handleTouchStart.bind(this);\n    this._handleTouchMove = this._handleTouchMove.bind(this);\n    this._handleTouchEnd = this._handleTouchEnd.bind(this);\n    this._handlePointerDown = this._handlePointerDown.bind(this);\n    this._handlePointerMove = this._handlePointerMove.bind(this);\n    this._handlePointerUp = this._handlePointerUp.bind(this);\n    this._ctx = canvas.getContext('2d', this.canvasContextOptions);\n    this.clear();\n    this.on();\n  }\n  clear() {\n    const {\n      _ctx: ctx,\n      canvas\n    } = this;\n    ctx.fillStyle = this.backgroundColor;\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n    ctx.fillRect(0, 0, canvas.width, canvas.height);\n    this._data = [];\n    this._reset(this._getPointGroupOptions());\n    this._isEmpty = true;\n    this._strokePointerId = undefined;\n  }\n  fromDataURL(dataUrl) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return new Promise((resolve, reject) => {\n      const image = new Image();\n      const ratio = options.ratio || window.devicePixelRatio || 1;\n      const width = options.width || this.canvas.width / ratio;\n      const height = options.height || this.canvas.height / ratio;\n      const xOffset = options.xOffset || 0;\n      const yOffset = options.yOffset || 0;\n      this._reset(this._getPointGroupOptions());\n      image.onload = () => {\n        this._ctx.drawImage(image, xOffset, yOffset, width, height);\n        resolve();\n      };\n      image.onerror = error => {\n        reject(error);\n      };\n      image.crossOrigin = 'anonymous';\n      image.src = dataUrl;\n      this._isEmpty = false;\n    });\n  }\n  toDataURL() {\n    let type = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'image/png';\n    let encoderOptions = arguments.length > 1 ? arguments[1] : undefined;\n    switch (type) {\n      case 'image/svg+xml':\n        if (typeof encoderOptions !== 'object') {\n          encoderOptions = undefined;\n        }\n        return \"data:image/svg+xml;base64,\".concat(btoa(this.toSVG(encoderOptions)));\n      default:\n        if (typeof encoderOptions !== 'number') {\n          encoderOptions = undefined;\n        }\n        return this.canvas.toDataURL(type, encoderOptions);\n    }\n  }\n  on() {\n    this.canvas.style.touchAction = 'none';\n    this.canvas.style.msTouchAction = 'none';\n    this.canvas.style.userSelect = 'none';\n    const isIOS = /Macintosh/.test(navigator.userAgent) && 'ontouchstart' in document;\n    if (window.PointerEvent && !isIOS) {\n      this._handlePointerEvents();\n    } else {\n      this._handleMouseEvents();\n      if ('ontouchstart' in window) {\n        this._handleTouchEvents();\n      }\n    }\n  }\n  off() {\n    this.canvas.style.touchAction = 'auto';\n    this.canvas.style.msTouchAction = 'auto';\n    this.canvas.style.userSelect = 'auto';\n    this.canvas.removeEventListener('pointerdown', this._handlePointerDown);\n    this.canvas.removeEventListener('mousedown', this._handleMouseDown);\n    this.canvas.removeEventListener('touchstart', this._handleTouchStart);\n    this._removeMoveUpEventListeners();\n  }\n  _getListenerFunctions() {\n    var _a;\n    const canvasWindow = window.document === this.canvas.ownerDocument ? window : (_a = this.canvas.ownerDocument.defaultView) !== null && _a !== void 0 ? _a : this.canvas.ownerDocument;\n    return {\n      addEventListener: canvasWindow.addEventListener.bind(canvasWindow),\n      removeEventListener: canvasWindow.removeEventListener.bind(canvasWindow)\n    };\n  }\n  _removeMoveUpEventListeners() {\n    const {\n      removeEventListener\n    } = this._getListenerFunctions();\n    removeEventListener('pointermove', this._handlePointerMove);\n    removeEventListener('pointerup', this._handlePointerUp);\n    removeEventListener('mousemove', this._handleMouseMove);\n    removeEventListener('mouseup', this._handleMouseUp);\n    removeEventListener('touchmove', this._handleTouchMove);\n    removeEventListener('touchend', this._handleTouchEnd);\n  }\n  isEmpty() {\n    return this._isEmpty;\n  }\n  fromData(pointGroups) {\n    let {\n      clear = true\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    if (clear) {\n      this.clear();\n    }\n    this._fromData(pointGroups, this._drawCurve.bind(this), this._drawDot.bind(this));\n    this._data = this._data.concat(pointGroups);\n  }\n  toData() {\n    return this._data;\n  }\n  _isLeftButtonPressed(event, only) {\n    if (only) {\n      return event.buttons === 1;\n    }\n    return (event.buttons & 1) === 1;\n  }\n  _pointerEventToSignatureEvent(event) {\n    return {\n      event: event,\n      type: event.type,\n      x: event.clientX,\n      y: event.clientY,\n      pressure: 'pressure' in event ? event.pressure : 0\n    };\n  }\n  _touchEventToSignatureEvent(event) {\n    const touch = event.changedTouches[0];\n    return {\n      event: event,\n      type: event.type,\n      x: touch.clientX,\n      y: touch.clientY,\n      pressure: touch.force\n    };\n  }\n  _handleMouseDown(event) {\n    if (!this._isLeftButtonPressed(event, true) || this._drawingStroke) {\n      return;\n    }\n    this._strokeBegin(this._pointerEventToSignatureEvent(event));\n  }\n  _handleMouseMove(event) {\n    if (!this._isLeftButtonPressed(event, true) || !this._drawingStroke) {\n      this._strokeEnd(this._pointerEventToSignatureEvent(event), false);\n      return;\n    }\n    this._strokeMoveUpdate(this._pointerEventToSignatureEvent(event));\n  }\n  _handleMouseUp(event) {\n    if (this._isLeftButtonPressed(event)) {\n      return;\n    }\n    this._strokeEnd(this._pointerEventToSignatureEvent(event));\n  }\n  _handleTouchStart(event) {\n    if (event.targetTouches.length !== 1 || this._drawingStroke) {\n      return;\n    }\n    if (event.cancelable) {\n      event.preventDefault();\n    }\n    this._strokeBegin(this._touchEventToSignatureEvent(event));\n  }\n  _handleTouchMove(event) {\n    if (event.targetTouches.length !== 1) {\n      return;\n    }\n    if (event.cancelable) {\n      event.preventDefault();\n    }\n    if (!this._drawingStroke) {\n      this._strokeEnd(this._touchEventToSignatureEvent(event), false);\n      return;\n    }\n    this._strokeMoveUpdate(this._touchEventToSignatureEvent(event));\n  }\n  _handleTouchEnd(event) {\n    if (event.targetTouches.length !== 0) {\n      return;\n    }\n    if (event.cancelable) {\n      event.preventDefault();\n    }\n    this._strokeEnd(this._touchEventToSignatureEvent(event));\n  }\n  _getPointerId(event) {\n    return event.persistentDeviceId || event.pointerId;\n  }\n  _allowPointerId(event) {\n    let allowUndefined = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    if (typeof this._strokePointerId === 'undefined') {\n      return allowUndefined;\n    }\n    return this._getPointerId(event) === this._strokePointerId;\n  }\n  _handlePointerDown(event) {\n    if (this._drawingStroke || !this._isLeftButtonPressed(event) || !this._allowPointerId(event, true)) {\n      return;\n    }\n    this._strokePointerId = this._getPointerId(event);\n    event.preventDefault();\n    this._strokeBegin(this._pointerEventToSignatureEvent(event));\n  }\n  _handlePointerMove(event) {\n    if (!this._allowPointerId(event)) {\n      return;\n    }\n    if (!this._isLeftButtonPressed(event, true) || !this._drawingStroke) {\n      this._strokeEnd(this._pointerEventToSignatureEvent(event), false);\n      return;\n    }\n    event.preventDefault();\n    this._strokeMoveUpdate(this._pointerEventToSignatureEvent(event));\n  }\n  _handlePointerUp(event) {\n    if (this._isLeftButtonPressed(event) || !this._allowPointerId(event)) {\n      return;\n    }\n    event.preventDefault();\n    this._strokeEnd(this._pointerEventToSignatureEvent(event));\n  }\n  _getPointGroupOptions(group) {\n    return {\n      penColor: group && 'penColor' in group ? group.penColor : this.penColor,\n      dotSize: group && 'dotSize' in group ? group.dotSize : this.dotSize,\n      minWidth: group && 'minWidth' in group ? group.minWidth : this.minWidth,\n      maxWidth: group && 'maxWidth' in group ? group.maxWidth : this.maxWidth,\n      velocityFilterWeight: group && 'velocityFilterWeight' in group ? group.velocityFilterWeight : this.velocityFilterWeight,\n      compositeOperation: group && 'compositeOperation' in group ? group.compositeOperation : this.compositeOperation\n    };\n  }\n  _strokeBegin(event) {\n    const cancelled = !this.dispatchEvent(new CustomEvent('beginStroke', {\n      detail: event,\n      cancelable: true\n    }));\n    if (cancelled) {\n      return;\n    }\n    const {\n      addEventListener\n    } = this._getListenerFunctions();\n    switch (event.event.type) {\n      case 'mousedown':\n        addEventListener('mousemove', this._handleMouseMove, {\n          passive: false\n        });\n        addEventListener('mouseup', this._handleMouseUp, {\n          passive: false\n        });\n        break;\n      case 'touchstart':\n        addEventListener('touchmove', this._handleTouchMove, {\n          passive: false\n        });\n        addEventListener('touchend', this._handleTouchEnd, {\n          passive: false\n        });\n        break;\n      case 'pointerdown':\n        addEventListener('pointermove', this._handlePointerMove, {\n          passive: false\n        });\n        addEventListener('pointerup', this._handlePointerUp, {\n          passive: false\n        });\n        break;\n    }\n    this._drawingStroke = true;\n    const pointGroupOptions = this._getPointGroupOptions();\n    const newPointGroup = Object.assign(Object.assign({}, pointGroupOptions), {\n      points: []\n    });\n    this._data.push(newPointGroup);\n    this._reset(pointGroupOptions);\n    this._strokeUpdate(event);\n  }\n  _strokeUpdate(event) {\n    if (!this._drawingStroke) {\n      return;\n    }\n    if (this._data.length === 0) {\n      this._strokeBegin(event);\n      return;\n    }\n    this.dispatchEvent(new CustomEvent('beforeUpdateStroke', {\n      detail: event\n    }));\n    const point = this._createPoint(event.x, event.y, event.pressure);\n    const lastPointGroup = this._data[this._data.length - 1];\n    const lastPoints = lastPointGroup.points;\n    const lastPoint = lastPoints.length > 0 && lastPoints[lastPoints.length - 1];\n    const isLastPointTooClose = lastPoint ? point.distanceTo(lastPoint) <= this.minDistance : false;\n    const pointGroupOptions = this._getPointGroupOptions(lastPointGroup);\n    if (!lastPoint || !(lastPoint && isLastPointTooClose)) {\n      const curve = this._addPoint(point, pointGroupOptions);\n      if (!lastPoint) {\n        this._drawDot(point, pointGroupOptions);\n      } else if (curve) {\n        this._drawCurve(curve, pointGroupOptions);\n      }\n      lastPoints.push({\n        time: point.time,\n        x: point.x,\n        y: point.y,\n        pressure: point.pressure\n      });\n    }\n    this.dispatchEvent(new CustomEvent('afterUpdateStroke', {\n      detail: event\n    }));\n  }\n  _strokeEnd(event) {\n    let shouldUpdate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    this._removeMoveUpEventListeners();\n    if (!this._drawingStroke) {\n      return;\n    }\n    if (shouldUpdate) {\n      this._strokeUpdate(event);\n    }\n    this._drawingStroke = false;\n    this._strokePointerId = undefined;\n    this.dispatchEvent(new CustomEvent('endStroke', {\n      detail: event\n    }));\n  }\n  _handlePointerEvents() {\n    this._drawingStroke = false;\n    this.canvas.addEventListener('pointerdown', this._handlePointerDown, {\n      passive: false\n    });\n  }\n  _handleMouseEvents() {\n    this._drawingStroke = false;\n    this.canvas.addEventListener('mousedown', this._handleMouseDown, {\n      passive: false\n    });\n  }\n  _handleTouchEvents() {\n    this.canvas.addEventListener('touchstart', this._handleTouchStart, {\n      passive: false\n    });\n  }\n  _reset(options) {\n    this._lastPoints = [];\n    this._lastVelocity = 0;\n    this._lastWidth = (options.minWidth + options.maxWidth) / 2;\n    this._ctx.fillStyle = options.penColor;\n    this._ctx.globalCompositeOperation = options.compositeOperation;\n  }\n  _createPoint(x, y, pressure) {\n    const rect = this.canvas.getBoundingClientRect();\n    return new Point(x - rect.left, y - rect.top, pressure, new Date().getTime());\n  }\n  _addPoint(point, options) {\n    const {\n      _lastPoints\n    } = this;\n    _lastPoints.push(point);\n    if (_lastPoints.length > 2) {\n      if (_lastPoints.length === 3) {\n        _lastPoints.unshift(_lastPoints[0]);\n      }\n      const widths = this._calculateCurveWidths(_lastPoints[1], _lastPoints[2], options);\n      const curve = Bezier.fromPoints(_lastPoints, widths);\n      _lastPoints.shift();\n      return curve;\n    }\n    return null;\n  }\n  _calculateCurveWidths(startPoint, endPoint, options) {\n    const velocity = options.velocityFilterWeight * endPoint.velocityFrom(startPoint) + (1 - options.velocityFilterWeight) * this._lastVelocity;\n    const newWidth = this._strokeWidth(velocity, options);\n    const widths = {\n      end: newWidth,\n      start: this._lastWidth\n    };\n    this._lastVelocity = velocity;\n    this._lastWidth = newWidth;\n    return widths;\n  }\n  _strokeWidth(velocity, options) {\n    return Math.max(options.maxWidth / (velocity + 1), options.minWidth);\n  }\n  _drawCurveSegment(x, y, width) {\n    const ctx = this._ctx;\n    ctx.moveTo(x, y);\n    ctx.arc(x, y, width, 0, 2 * Math.PI, false);\n    this._isEmpty = false;\n  }\n  _drawCurve(curve, options) {\n    const ctx = this._ctx;\n    const widthDelta = curve.endWidth - curve.startWidth;\n    const drawSteps = Math.ceil(curve.length()) * 2;\n    ctx.beginPath();\n    ctx.fillStyle = options.penColor;\n    for (let i = 0; i < drawSteps; i += 1) {\n      const t = i / drawSteps;\n      const tt = t * t;\n      const ttt = tt * t;\n      const u = 1 - t;\n      const uu = u * u;\n      const uuu = uu * u;\n      let x = uuu * curve.startPoint.x;\n      x += 3 * uu * t * curve.control1.x;\n      x += 3 * u * tt * curve.control2.x;\n      x += ttt * curve.endPoint.x;\n      let y = uuu * curve.startPoint.y;\n      y += 3 * uu * t * curve.control1.y;\n      y += 3 * u * tt * curve.control2.y;\n      y += ttt * curve.endPoint.y;\n      const width = Math.min(curve.startWidth + ttt * widthDelta, options.maxWidth);\n      this._drawCurveSegment(x, y, width);\n    }\n    ctx.closePath();\n    ctx.fill();\n  }\n  _drawDot(point, options) {\n    const ctx = this._ctx;\n    const width = options.dotSize > 0 ? options.dotSize : (options.minWidth + options.maxWidth) / 2;\n    ctx.beginPath();\n    this._drawCurveSegment(point.x, point.y, width);\n    ctx.closePath();\n    ctx.fillStyle = options.penColor;\n    ctx.fill();\n  }\n  _fromData(pointGroups, drawCurve, drawDot) {\n    for (const group of pointGroups) {\n      const {\n        points\n      } = group;\n      const pointGroupOptions = this._getPointGroupOptions(group);\n      if (points.length > 1) {\n        for (let j = 0; j < points.length; j += 1) {\n          const basicPoint = points[j];\n          const point = new Point(basicPoint.x, basicPoint.y, basicPoint.pressure, basicPoint.time);\n          if (j === 0) {\n            this._reset(pointGroupOptions);\n          }\n          const curve = this._addPoint(point, pointGroupOptions);\n          if (curve) {\n            drawCurve(curve, pointGroupOptions);\n          }\n        }\n      } else {\n        this._reset(pointGroupOptions);\n        drawDot(points[0], pointGroupOptions);\n      }\n    }\n  }\n  toSVG() {\n    let {\n      includeBackgroundColor = false\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const pointGroups = this._data;\n    const ratio = Math.max(window.devicePixelRatio || 1, 1);\n    const minX = 0;\n    const minY = 0;\n    const maxX = this.canvas.width / ratio;\n    const maxY = this.canvas.height / ratio;\n    const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');\n    svg.setAttribute('xmlns', 'http://www.w3.org/2000/svg');\n    svg.setAttribute('xmlns:xlink', 'http://www.w3.org/1999/xlink');\n    svg.setAttribute('viewBox', \"\".concat(minX, \" \").concat(minY, \" \").concat(maxX, \" \").concat(maxY));\n    svg.setAttribute('width', maxX.toString());\n    svg.setAttribute('height', maxY.toString());\n    if (includeBackgroundColor && this.backgroundColor) {\n      const rect = document.createElement('rect');\n      rect.setAttribute('width', '100%');\n      rect.setAttribute('height', '100%');\n      rect.setAttribute('fill', this.backgroundColor);\n      svg.appendChild(rect);\n    }\n    this._fromData(pointGroups, (curve, _ref) => {\n      let {\n        penColor\n      } = _ref;\n      const path = document.createElement('path');\n      if (!isNaN(curve.control1.x) && !isNaN(curve.control1.y) && !isNaN(curve.control2.x) && !isNaN(curve.control2.y)) {\n        const attr = \"M \".concat(curve.startPoint.x.toFixed(3), \",\").concat(curve.startPoint.y.toFixed(3), \" \") + \"C \".concat(curve.control1.x.toFixed(3), \",\").concat(curve.control1.y.toFixed(3), \" \") + \"\".concat(curve.control2.x.toFixed(3), \",\").concat(curve.control2.y.toFixed(3), \" \") + \"\".concat(curve.endPoint.x.toFixed(3), \",\").concat(curve.endPoint.y.toFixed(3));\n        path.setAttribute('d', attr);\n        path.setAttribute('stroke-width', (curve.endWidth * 2.25).toFixed(3));\n        path.setAttribute('stroke', penColor);\n        path.setAttribute('fill', 'none');\n        path.setAttribute('stroke-linecap', 'round');\n        svg.appendChild(path);\n      }\n    }, (point, _ref2) => {\n      let {\n        penColor,\n        dotSize,\n        minWidth,\n        maxWidth\n      } = _ref2;\n      const circle = document.createElement('circle');\n      const size = dotSize > 0 ? dotSize : (minWidth + maxWidth) / 2;\n      circle.setAttribute('r', size.toString());\n      circle.setAttribute('cx', point.x.toString());\n      circle.setAttribute('cy', point.y.toString());\n      circle.setAttribute('fill', penColor);\n      svg.appendChild(circle);\n    });\n    return svg.outerHTML;\n  }\n}\nexport { SignaturePad as default };","map":{"version":3,"names":["Point","constructor","x","y","pressure","time","isNaN","Error","concat","Date","now","distanceTo","start","Math","sqrt","pow","equals","other","velocityFrom","Bezier","fromPoints","points","widths","c2","calculateControlPoints","c3","c1","end","s1","s2","s3","dx1","dy1","dx2","dy2","m1","m2","l1","l2","dxm","dym","k","cm","tx","ty","startPoint","control2","control1","endPoint","startWidth","endWidth","length","steps","px","py","i","t","cx","point","cy","xdiff","ydiff","SignatureEventTarget","_et","EventTarget","_a","document","addEventListener","type","listener","options","dispatchEvent","event","removeEventListener","callback","throttle","fn","wait","arguments","undefined","previous","timeout","result","storedContext","storedArgs","later","apply","wrapper","remaining","_len","args","Array","_key","clearTimeout","window","setTimeout","SignaturePad","canvas","_drawingStroke","_isEmpty","_lastPoints","_data","_lastVelocity","_lastWidth","velocityFilterWeight","minWidth","maxWidth","minDistance","_b","dotSize","penColor","backgroundColor","compositeOperation","canvasContextOptions","_c","_strokeMoveUpdate","prototype","_strokeUpdate","_handleMouseDown","bind","_handleMouseMove","_handleMouseUp","_handleTouchStart","_handleTouchMove","_handleTouchEnd","_handlePointerDown","_handlePointerMove","_handlePointerUp","_ctx","getContext","clear","on","ctx","fillStyle","clearRect","width","height","fillRect","_reset","_getPointGroupOptions","_strokePointerId","fromDataURL","dataUrl","Promise","resolve","reject","image","Image","ratio","devicePixelRatio","xOffset","yOffset","onload","drawImage","onerror","error","crossOrigin","src","toDataURL","encoderOptions","btoa","toSVG","style","touchAction","msTouchAction","userSelect","isIOS","test","navigator","userAgent","PointerEvent","_handlePointerEvents","_handleMouseEvents","_handleTouchEvents","off","_removeMoveUpEventListeners","_getListenerFunctions","canvasWindow","ownerDocument","defaultView","isEmpty","fromData","pointGroups","_fromData","_drawCurve","_drawDot","toData","_isLeftButtonPressed","only","buttons","_pointerEventToSignatureEvent","clientX","clientY","_touchEventToSignatureEvent","touch","changedTouches","force","_strokeBegin","_strokeEnd","targetTouches","cancelable","preventDefault","_getPointerId","persistentDeviceId","pointerId","_allowPointerId","allowUndefined","group","cancelled","CustomEvent","detail","passive","pointGroupOptions","newPointGroup","Object","assign","push","_createPoint","lastPointGroup","lastPoints","lastPoint","isLastPointTooClose","curve","_addPoint","shouldUpdate","globalCompositeOperation","rect","getBoundingClientRect","left","top","getTime","unshift","_calculateCurveWidths","shift","velocity","newWidth","_strokeWidth","max","_drawCurveSegment","moveTo","arc","PI","widthDelta","drawSteps","ceil","beginPath","tt","ttt","u","uu","uuu","min","closePath","fill","drawCurve","drawDot","j","basicPoint","includeBackgroundColor","minX","minY","maxX","maxY","svg","createElementNS","setAttribute","toString","createElement","appendChild","_ref","path","attr","toFixed","_ref2","circle","size","outerHTML"],"sources":["D:\\Doc Sign\\client\\node_modules\\signature_pad\\src\\point.ts","D:\\Doc Sign\\client\\node_modules\\signature_pad\\src\\bezier.ts","D:\\Doc Sign\\client\\node_modules\\signature_pad\\src\\signature_event_target.ts","D:\\Doc Sign\\client\\node_modules\\signature_pad\\src\\throttle.ts","D:\\Doc Sign\\client\\node_modules\\signature_pad\\src\\signature_pad.ts"],"sourcesContent":["// Interface for point data structure used e.g. in SignaturePad#fromData method\nexport interface BasicPoint {\n  x: number;\n  y: number;\n  pressure: number;\n  time: number;\n}\n\nexport class Point implements BasicPoint {\n  public x: number;\n  public y: number;\n  public pressure: number;\n  public time: number;\n\n  constructor(x: number, y: number, pressure?: number, time?: number) {\n    if (isNaN(x) || isNaN(y)) {\n      throw new Error(`Point is invalid: (${x}, ${y})`);\n    }\n    this.x = +x;\n    this.y = +y;\n    this.pressure = pressure || 0;\n    this.time = time || Date.now();\n  }\n\n  public distanceTo(start: BasicPoint): number {\n    return Math.sqrt(\n      Math.pow(this.x - start.x, 2) + Math.pow(this.y - start.y, 2),\n    );\n  }\n\n  public equals(other: BasicPoint): boolean {\n    return (\n      this.x === other.x &&\n      this.y === other.y &&\n      this.pressure === other.pressure &&\n      this.time === other.time\n    );\n  }\n\n  public velocityFrom(start: BasicPoint): number {\n    return this.time !== start.time\n      ? this.distanceTo(start) / (this.time - start.time)\n      : 0;\n  }\n}\n","import { BasicPoint, Point } from './point';\n\nexport class Bezier {\n  public static fromPoints(\n    points: Point[],\n    widths: { start: number; end: number },\n  ): Bezier {\n    const c2 = this.calculateControlPoints(points[0], points[1], points[2]).c2;\n    const c3 = this.calculateControlPoints(points[1], points[2], points[3]).c1;\n\n    return new Bezier(points[1], c2, c3, points[2], widths.start, widths.end);\n  }\n\n  private static calculateControlPoints(\n    s1: BasicPoint,\n    s2: BasicPoint,\n    s3: BasicPoint,\n  ): {\n    c1: BasicPoint;\n    c2: BasicPoint;\n  } {\n    const dx1 = s1.x - s2.x;\n    const dy1 = s1.y - s2.y;\n    const dx2 = s2.x - s3.x;\n    const dy2 = s2.y - s3.y;\n\n    const m1 = { x: (s1.x + s2.x) / 2.0, y: (s1.y + s2.y) / 2.0 };\n    const m2 = { x: (s2.x + s3.x) / 2.0, y: (s2.y + s3.y) / 2.0 };\n\n    const l1 = Math.sqrt(dx1 * dx1 + dy1 * dy1);\n    const l2 = Math.sqrt(dx2 * dx2 + dy2 * dy2);\n\n    const dxm = m1.x - m2.x;\n    const dym = m1.y - m2.y;\n\n    const k = l1 + l2 == 0 ? 0 : l2 / (l1 + l2);\n    const cm = { x: m2.x + dxm * k, y: m2.y + dym * k };\n\n    const tx = s2.x - cm.x;\n    const ty = s2.y - cm.y;\n\n    return {\n      c1: new Point(m1.x + tx, m1.y + ty),\n      c2: new Point(m2.x + tx, m2.y + ty),\n    };\n  }\n\n  constructor(\n    public startPoint: Point,\n    public control2: BasicPoint,\n    public control1: BasicPoint,\n    public endPoint: Point,\n    public startWidth: number,\n    public endWidth: number,\n  ) {}\n\n  // Returns approximated length. Code taken from https://www.lemoda.net/maths/bezier-length/index.html.\n  public length(): number {\n    const steps = 10;\n    let length = 0;\n    let px;\n    let py;\n\n    for (let i = 0; i <= steps; i += 1) {\n      const t = i / steps;\n      const cx = this.point(\n        t,\n        this.startPoint.x,\n        this.control1.x,\n        this.control2.x,\n        this.endPoint.x,\n      );\n      const cy = this.point(\n        t,\n        this.startPoint.y,\n        this.control1.y,\n        this.control2.y,\n        this.endPoint.y,\n      );\n\n      if (i > 0) {\n        const xdiff = cx - (px as number);\n        const ydiff = cy - (py as number);\n\n        length += Math.sqrt(xdiff * xdiff + ydiff * ydiff);\n      }\n\n      px = cx;\n      py = cy;\n    }\n\n    return length;\n  }\n\n  // Calculate parametric value of x or y given t and the four point coordinates of a cubic bezier curve.\n  private point(\n    t: number,\n    start: number,\n    c1: number,\n    c2: number,\n    end: number,\n  ): number {\n    // prettier-ignore\n    return (       start * (1.0 - t) * (1.0 - t)  * (1.0 - t))\n         + (3.0 *  c1    * (1.0 - t) * (1.0 - t)  * t)\n         + (3.0 *  c2    * (1.0 - t) * t          * t)\n         + (       end   * t         * t          * t);\n  }\n}\n","export class SignatureEventTarget {\n  /* tslint:disable: variable-name */\n  private _et: EventTarget;\n  /* tslint:enable: variable-name */\n\n  constructor() {\n    try {\n      this._et = new EventTarget();\n    } catch {\n      // Using document as EventTarget to support iOS 13 and older.\n      // Because EventTarget constructor just exists at iOS 14 and later.\n      this._et = document;\n    }\n  }\n\n  addEventListener(\n    type: string,\n    listener: EventListenerOrEventListenerObject | null,\n    options?: boolean | AddEventListenerOptions,\n  ): void {\n    this._et.addEventListener(type, listener, options);\n  }\n\n  dispatchEvent(event: Event): boolean {\n    return this._et.dispatchEvent(event);\n  }\n\n  removeEventListener(\n    type: string,\n    callback: EventListenerOrEventListenerObject | null,\n    options?: boolean | EventListenerOptions,\n  ): void {\n    this._et.removeEventListener(type, callback, options);\n  }\n}\n","/* eslint-disable @typescript-eslint/no-explicit-any, @typescript-eslint/no-this-alias */\n// Slightly simplified version of http://stackoverflow.com/a/27078401/815507\n\nexport function throttle(\n  fn: (...args: any[]) => any,\n  wait = 250,\n): (this: any, ...args: any[]) => any {\n  let previous = 0;\n  let timeout: number | null = null;\n  let result: any;\n  let storedContext: any;\n  let storedArgs: any[];\n\n  const later = (): void => {\n    previous = Date.now();\n    timeout = null;\n    result = fn.apply(storedContext, storedArgs);\n\n    if (!timeout) {\n      storedContext = null;\n      storedArgs = [];\n    }\n  };\n\n  return function wrapper(this: any, ...args: any[]): any {\n    const now = Date.now();\n    const remaining = wait - (now - previous);\n\n    storedContext = this;\n    storedArgs = args;\n\n    if (remaining <= 0 || remaining > wait) {\n      if (timeout) {\n        clearTimeout(timeout);\n        timeout = null;\n      }\n\n      previous = now;\n      result = fn.apply(storedContext, storedArgs);\n\n      if (!timeout) {\n        storedContext = null;\n        storedArgs = [];\n      }\n    } else if (!timeout) {\n      timeout = window.setTimeout(later, remaining);\n    }\n\n    return result;\n  };\n}\n","/**\n * The main idea and some parts of the code (e.g. drawing variable width Bézier curve) are taken from:\n * http://corner.squareup.com/2012/07/smoother-signatures.html\n *\n * Implementation of interpolation using cubic Bézier curves is taken from:\n * https://web.archive.org/web/20160323213433/http://www.benknowscode.com/2012/09/path-interpolation-using-cubic-bezier_9742.html\n *\n * Algorithm for approximated length of a Bézier curve is taken from:\n * http://www.lemoda.net/maths/bezier-length/index.html\n */\n\nimport { Bezier } from './bezier';\nimport { BasicPoint, Point } from './point';\nimport { SignatureEventTarget } from './signature_event_target';\nimport { throttle } from './throttle';\n\nexport { BasicPoint } from './point';\n\nexport interface SignatureEvent {\n  event: MouseEvent | TouchEvent | PointerEvent;\n  type: string;\n  x: number;\n  y: number;\n  pressure: number;\n}\n\nexport interface FromDataOptions {\n  clear?: boolean;\n}\n\nexport interface ToSVGOptions {\n  includeBackgroundColor?: boolean;\n}\n\nexport interface PointGroupOptions {\n  dotSize: number;\n  minWidth: number;\n  maxWidth: number;\n  penColor: string;\n  velocityFilterWeight: number;\n  /**\n   * This is the globalCompositeOperation for the line.\n   * *default: 'source-over'*\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/globalCompositeOperation\n   */\n  compositeOperation: GlobalCompositeOperation;\n}\n\nexport interface Options extends Partial<PointGroupOptions> {\n  minDistance?: number;\n  backgroundColor?: string;\n  throttle?: number;\n  canvasContextOptions?: CanvasRenderingContext2DSettings;\n}\n\nexport interface PointGroup extends PointGroupOptions {\n  points: BasicPoint[];\n}\n\nexport default class SignaturePad extends SignatureEventTarget {\n  // Public stuff\n  public dotSize: number;\n  public minWidth: number;\n  public maxWidth: number;\n  public penColor: string;\n  public minDistance: number;\n  public velocityFilterWeight: number;\n  public compositeOperation: GlobalCompositeOperation;\n  public backgroundColor: string;\n  public throttle: number;\n  public canvasContextOptions: CanvasRenderingContext2DSettings;\n\n  // Private stuff\n  /* tslint:disable: variable-name */\n  private _ctx: CanvasRenderingContext2D;\n  private _drawingStroke = false;\n  private _isEmpty = true;\n  private _lastPoints: Point[] = []; // Stores up to 4 most recent points; used to generate a new curve\n  private _data: PointGroup[] = []; // Stores all points in groups (one group per line or dot)\n  private _lastVelocity = 0;\n  private _lastWidth = 0;\n  private _strokeMoveUpdate: (event: SignatureEvent) => void;\n  private _strokePointerId: number | undefined;\n  /* tslint:enable: variable-name */\n\n  constructor(\n    private canvas: HTMLCanvasElement,\n    options: Options = {},\n  ) {\n    super();\n    this.velocityFilterWeight = options.velocityFilterWeight || 0.7;\n    this.minWidth = options.minWidth || 0.5;\n    this.maxWidth = options.maxWidth || 2.5;\n\n    // We need to handle 0 value, so use `??` instead of `||`\n    this.throttle = options.throttle ?? 16; // in milliseconds\n    this.minDistance = options.minDistance ?? 5; // in pixels\n    this.dotSize = options.dotSize || 0;\n    this.penColor = options.penColor || 'black';\n    this.backgroundColor = options.backgroundColor || 'rgba(0,0,0,0)';\n    this.compositeOperation = options.compositeOperation || 'source-over';\n    this.canvasContextOptions = options.canvasContextOptions ?? {};\n\n    this._strokeMoveUpdate = this.throttle\n      ? throttle(SignaturePad.prototype._strokeUpdate, this.throttle)\n      : SignaturePad.prototype._strokeUpdate;\n\n    this._handleMouseDown = this._handleMouseDown.bind(this);\n    this._handleMouseMove = this._handleMouseMove.bind(this);\n    this._handleMouseUp = this._handleMouseUp.bind(this);\n    this._handleTouchStart = this._handleTouchStart.bind(this);\n    this._handleTouchMove = this._handleTouchMove.bind(this);\n    this._handleTouchEnd = this._handleTouchEnd.bind(this);\n    this._handlePointerDown = this._handlePointerDown.bind(this);\n    this._handlePointerMove = this._handlePointerMove.bind(this);\n    this._handlePointerUp = this._handlePointerUp.bind(this);\n\n    this._ctx = canvas.getContext(\n      '2d',\n      this.canvasContextOptions,\n    ) as CanvasRenderingContext2D;\n\n    this.clear();\n\n    // Enable mouse and touch event handlers\n    this.on();\n  }\n\n  public clear(): void {\n    const { _ctx: ctx, canvas } = this;\n\n    // Clear canvas using background color\n    ctx.fillStyle = this.backgroundColor;\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n    ctx.fillRect(0, 0, canvas.width, canvas.height);\n\n    this._data = [];\n    this._reset(this._getPointGroupOptions());\n    this._isEmpty = true;\n    this._strokePointerId = undefined;\n  }\n\n  public fromDataURL(\n    dataUrl: string,\n    options: {\n      ratio?: number;\n      width?: number;\n      height?: number;\n      xOffset?: number;\n      yOffset?: number;\n    } = {},\n  ): Promise<void> {\n    return new Promise((resolve, reject) => {\n      const image = new Image();\n      const ratio = options.ratio || window.devicePixelRatio || 1;\n      const width = options.width || this.canvas.width / ratio;\n      const height = options.height || this.canvas.height / ratio;\n      const xOffset = options.xOffset || 0;\n      const yOffset = options.yOffset || 0;\n\n      this._reset(this._getPointGroupOptions());\n\n      image.onload = (): void => {\n        this._ctx.drawImage(image, xOffset, yOffset, width, height);\n        resolve();\n      };\n      image.onerror = (error): void => {\n        reject(error);\n      };\n      image.crossOrigin = 'anonymous';\n      image.src = dataUrl;\n\n      this._isEmpty = false;\n    });\n  }\n\n  public toDataURL(\n    type: 'image/svg+xml',\n    encoderOptions?: ToSVGOptions,\n  ): string;\n  public toDataURL(type?: string, encoderOptions?: number): string;\n  public toDataURL(\n    type = 'image/png',\n    encoderOptions?: number | ToSVGOptions | undefined,\n  ): string {\n    switch (type) {\n      case 'image/svg+xml':\n        if (typeof encoderOptions !== 'object') {\n          encoderOptions = undefined;\n        }\n        return `data:image/svg+xml;base64,${btoa(\n          this.toSVG(encoderOptions as ToSVGOptions),\n        )}`;\n      default:\n        if (typeof encoderOptions !== 'number') {\n          encoderOptions = undefined;\n        }\n        return this.canvas.toDataURL(type, encoderOptions as number);\n    }\n  }\n\n  public on(): void {\n    // Disable panning/zooming when touching canvas element\n    this.canvas.style.touchAction = 'none';\n    (\n      this.canvas.style as CSSStyleDeclaration & {\n        msTouchAction: string | null;\n      }\n    ).msTouchAction = 'none';\n    this.canvas.style.userSelect = 'none';\n\n    const isIOS =\n      /Macintosh/.test(navigator.userAgent) && 'ontouchstart' in document;\n\n    // The \"Scribble\" feature of iOS intercepts point events. So that we can\n    // lose some of them when tapping rapidly. Use touch events for iOS\n    // platforms to prevent it. See\n    // https://developer.apple.com/forums/thread/664108 for more information.\n    if (window.PointerEvent && !isIOS) {\n      this._handlePointerEvents();\n    } else {\n      this._handleMouseEvents();\n\n      if ('ontouchstart' in window) {\n        this._handleTouchEvents();\n      }\n    }\n  }\n\n  public off(): void {\n    // Enable panning/zooming when touching canvas element\n    this.canvas.style.touchAction = 'auto';\n    (\n      this.canvas.style as CSSStyleDeclaration & {\n        msTouchAction: string | null;\n      }\n    ).msTouchAction = 'auto';\n    this.canvas.style.userSelect = 'auto';\n\n    this.canvas.removeEventListener('pointerdown', this._handlePointerDown);\n    this.canvas.removeEventListener('mousedown', this._handleMouseDown);\n    this.canvas.removeEventListener('touchstart', this._handleTouchStart);\n\n    this._removeMoveUpEventListeners();\n  }\n\n  private _getListenerFunctions() {\n    const canvasWindow =\n      window.document === this.canvas.ownerDocument\n        ? window\n        : (this.canvas.ownerDocument.defaultView ?? this.canvas.ownerDocument);\n\n    return {\n      addEventListener: canvasWindow.addEventListener.bind(\n        canvasWindow,\n      ) as typeof window.addEventListener,\n      removeEventListener: canvasWindow.removeEventListener.bind(\n        canvasWindow,\n      ) as typeof window.removeEventListener,\n    };\n  }\n\n  private _removeMoveUpEventListeners(): void {\n    const { removeEventListener } = this._getListenerFunctions();\n    removeEventListener('pointermove', this._handlePointerMove);\n    removeEventListener('pointerup', this._handlePointerUp);\n\n    removeEventListener('mousemove', this._handleMouseMove);\n    removeEventListener('mouseup', this._handleMouseUp);\n\n    removeEventListener('touchmove', this._handleTouchMove);\n    removeEventListener('touchend', this._handleTouchEnd);\n  }\n\n  public isEmpty(): boolean {\n    return this._isEmpty;\n  }\n\n  public fromData(\n    pointGroups: PointGroup[],\n    { clear = true }: FromDataOptions = {},\n  ): void {\n    if (clear) {\n      this.clear();\n    }\n\n    this._fromData(\n      pointGroups,\n      this._drawCurve.bind(this),\n      this._drawDot.bind(this),\n    );\n\n    this._data = this._data.concat(pointGroups);\n  }\n\n  public toData(): PointGroup[] {\n    return this._data;\n  }\n\n  private _isLeftButtonPressed(event: MouseEvent, only?: boolean): boolean {\n    if (only) {\n      return event.buttons === 1;\n    }\n\n    return (event.buttons & 1) === 1;\n  }\n  private _pointerEventToSignatureEvent(\n    event: MouseEvent | PointerEvent,\n  ): SignatureEvent {\n    return {\n      event: event,\n      type: event.type,\n      x: event.clientX,\n      y: event.clientY,\n      pressure: 'pressure' in event ? event.pressure : 0,\n    };\n  }\n\n  private _touchEventToSignatureEvent(event: TouchEvent): SignatureEvent {\n    const touch = event.changedTouches[0];\n    return {\n      event: event,\n      type: event.type,\n      x: touch.clientX,\n      y: touch.clientY,\n      pressure: touch.force,\n    };\n  }\n\n  // Event handlers\n  private _handleMouseDown(event: MouseEvent): void {\n    if (!this._isLeftButtonPressed(event, true) || this._drawingStroke) {\n      return;\n    }\n    this._strokeBegin(this._pointerEventToSignatureEvent(event));\n  };\n\n  private _handleMouseMove(event: MouseEvent): void {\n    if (!this._isLeftButtonPressed(event, true) || !this._drawingStroke) {\n      // Stop when not pressing primary button or pressing multiple buttons\n      this._strokeEnd(this._pointerEventToSignatureEvent(event), false);\n      return;\n    }\n\n    this._strokeMoveUpdate(this._pointerEventToSignatureEvent(event));\n  };\n\n  private _handleMouseUp(event: MouseEvent): void {\n    if (this._isLeftButtonPressed(event)) {\n      return;\n    }\n\n    this._strokeEnd(this._pointerEventToSignatureEvent(event));\n  };\n\n  private _handleTouchStart(event: TouchEvent): void {\n    if (event.targetTouches.length !== 1 || this._drawingStroke) {\n      return;\n    }\n\n    // Prevent scrolling.\n    if (event.cancelable) {\n      event.preventDefault();\n    }\n\n    this._strokeBegin(this._touchEventToSignatureEvent(event));\n  };\n\n  private _handleTouchMove(event: TouchEvent): void {\n    if (event.targetTouches.length !== 1) {\n      return;\n    }\n\n    // Prevent scrolling.\n    if (event.cancelable) {\n      event.preventDefault();\n    }\n\n    if (!this._drawingStroke) {\n      this._strokeEnd(this._touchEventToSignatureEvent(event), false);\n      return;\n    }\n\n    this._strokeMoveUpdate(this._touchEventToSignatureEvent(event));\n  };\n\n  private _handleTouchEnd(event: TouchEvent): void {\n    if (event.targetTouches.length !== 0) {\n      return;\n    }\n\n    if (event.cancelable) {\n      event.preventDefault();\n    }\n\n    this._strokeEnd(this._touchEventToSignatureEvent(event));\n  };\n\n  private _getPointerId(event: PointerEvent) {\n    // @ts-expect-error persistentDeviceId is not available yet but we want to use it when it is available\n    return event.persistentDeviceId || event.pointerId;\n  }\n\n  private _allowPointerId(event: PointerEvent, allowUndefined = false): boolean {\n    if (typeof this._strokePointerId === 'undefined') {\n      return allowUndefined;\n    }\n\n    return this._getPointerId(event) === this._strokePointerId;\n  }\n\n  private _handlePointerDown(event: PointerEvent): void {\n    if (\n      this._drawingStroke ||\n      !this._isLeftButtonPressed(event) ||\n      !this._allowPointerId(event, true)\n    ) {\n      return;\n    }\n\n    this._strokePointerId = this._getPointerId(event);\n\n    event.preventDefault();\n\n    this._strokeBegin(this._pointerEventToSignatureEvent(event));\n  };\n\n  private _handlePointerMove(event: PointerEvent): void {\n    if (!this._allowPointerId(event)) {\n      return;\n    }\n    if (!this._isLeftButtonPressed(event, true) || !this._drawingStroke) {\n      // Stop when primary button not pressed or multiple buttons pressed\n      this._strokeEnd(this._pointerEventToSignatureEvent(event), false);\n      return;\n    }\n\n    event.preventDefault();\n    this._strokeMoveUpdate(this._pointerEventToSignatureEvent(event));\n  };\n\n  private _handlePointerUp(event: PointerEvent): void {\n    if (\n      this._isLeftButtonPressed(event) ||\n      !this._allowPointerId(event)\n    ) {\n      return;\n    }\n\n    event.preventDefault();\n    this._strokeEnd(this._pointerEventToSignatureEvent(event));\n  };\n\n  private _getPointGroupOptions(group?: PointGroup): PointGroupOptions {\n    return {\n      penColor: group && 'penColor' in group ? group.penColor : this.penColor,\n      dotSize: group && 'dotSize' in group ? group.dotSize : this.dotSize,\n      minWidth: group && 'minWidth' in group ? group.minWidth : this.minWidth,\n      maxWidth: group && 'maxWidth' in group ? group.maxWidth : this.maxWidth,\n      velocityFilterWeight:\n        group && 'velocityFilterWeight' in group\n          ? group.velocityFilterWeight\n          : this.velocityFilterWeight,\n      compositeOperation:\n        group && 'compositeOperation' in group\n          ? group.compositeOperation\n          : this.compositeOperation,\n    };\n  }\n\n  // Private methods\n  private _strokeBegin(event: SignatureEvent): void {\n    const cancelled = !this.dispatchEvent(\n      new CustomEvent('beginStroke', { detail: event, cancelable: true }),\n    );\n    if (cancelled) {\n      return;\n    }\n\n    const { addEventListener } = this._getListenerFunctions();\n    switch (event.event.type) {\n      case 'mousedown':\n        addEventListener('mousemove', this._handleMouseMove, {\n          passive: false,\n        });\n        addEventListener('mouseup', this._handleMouseUp, { passive: false });\n        break;\n      case 'touchstart':\n        addEventListener('touchmove', this._handleTouchMove, {\n          passive: false,\n        });\n        addEventListener('touchend', this._handleTouchEnd, { passive: false });\n        break;\n      case 'pointerdown':\n        addEventListener('pointermove', this._handlePointerMove, {\n          passive: false,\n        });\n        addEventListener('pointerup', this._handlePointerUp, {\n          passive: false,\n        });\n        break;\n      default:\n      // do nothing\n    }\n\n    this._drawingStroke = true;\n\n    const pointGroupOptions = this._getPointGroupOptions();\n\n    const newPointGroup: PointGroup = {\n      ...pointGroupOptions,\n      points: [],\n    };\n\n    this._data.push(newPointGroup);\n    this._reset(pointGroupOptions);\n    this._strokeUpdate(event);\n  }\n\n  private _strokeUpdate(event: SignatureEvent): void {\n    if (!this._drawingStroke) {\n      return;\n    }\n\n    if (this._data.length === 0) {\n      // This can happen if clear() was called while a signature is still in progress,\n      // or if there is a race condition between start/update events.\n      this._strokeBegin(event);\n      return;\n    }\n\n    this.dispatchEvent(\n      new CustomEvent('beforeUpdateStroke', { detail: event }),\n    );\n\n    const point = this._createPoint(event.x, event.y, event.pressure);\n    const lastPointGroup = this._data[this._data.length - 1];\n    const lastPoints = lastPointGroup.points;\n    const lastPoint =\n      lastPoints.length > 0 && lastPoints[lastPoints.length - 1];\n    const isLastPointTooClose = lastPoint\n      ? point.distanceTo(lastPoint) <= this.minDistance\n      : false;\n    const pointGroupOptions = this._getPointGroupOptions(lastPointGroup);\n\n    // Skip this point if it's too close to the previous one\n    if (!lastPoint || !(lastPoint && isLastPointTooClose)) {\n      const curve = this._addPoint(point, pointGroupOptions);\n\n      if (!lastPoint) {\n        this._drawDot(point, pointGroupOptions);\n      } else if (curve) {\n        this._drawCurve(curve, pointGroupOptions);\n      }\n\n      lastPoints.push({\n        time: point.time,\n        x: point.x,\n        y: point.y,\n        pressure: point.pressure,\n      });\n    }\n\n    this.dispatchEvent(new CustomEvent('afterUpdateStroke', { detail: event }));\n  }\n\n  private _strokeEnd(event: SignatureEvent, shouldUpdate = true): void {\n    this._removeMoveUpEventListeners();\n\n    if (!this._drawingStroke) {\n      return;\n    }\n\n    if (shouldUpdate) {\n      this._strokeUpdate(event);\n    }\n\n    this._drawingStroke = false;\n    this._strokePointerId = undefined;\n    this.dispatchEvent(new CustomEvent('endStroke', { detail: event }));\n  }\n\n  private _handlePointerEvents(): void {\n    this._drawingStroke = false;\n\n    this.canvas.addEventListener('pointerdown', this._handlePointerDown, {\n      passive: false,\n    });\n  }\n\n  private _handleMouseEvents(): void {\n    this._drawingStroke = false;\n\n    this.canvas.addEventListener('mousedown', this._handleMouseDown, {\n      passive: false,\n    });\n  }\n\n  private _handleTouchEvents(): void {\n    this.canvas.addEventListener('touchstart', this._handleTouchStart, {\n      passive: false,\n    });\n  }\n\n  // Called when a new line is started\n  private _reset(options: PointGroupOptions): void {\n    this._lastPoints = [];\n    this._lastVelocity = 0;\n    this._lastWidth = (options.minWidth + options.maxWidth) / 2;\n    this._ctx.fillStyle = options.penColor;\n    this._ctx.globalCompositeOperation = options.compositeOperation;\n  }\n\n  private _createPoint(x: number, y: number, pressure: number): Point {\n    const rect = this.canvas.getBoundingClientRect();\n\n    return new Point(\n      x - rect.left,\n      y - rect.top,\n      pressure,\n      new Date().getTime(),\n    );\n  }\n\n  // Add point to _lastPoints array and generate a new curve if there are enough points (i.e. 3)\n  private _addPoint(point: Point, options: PointGroupOptions): Bezier | null {\n    const { _lastPoints } = this;\n\n    _lastPoints.push(point);\n\n    if (_lastPoints.length > 2) {\n      // To reduce the initial lag make it work with 3 points\n      // by copying the first point to the beginning.\n      if (_lastPoints.length === 3) {\n        _lastPoints.unshift(_lastPoints[0]);\n      }\n\n      // _points array will always have 4 points here.\n      const widths = this._calculateCurveWidths(\n        _lastPoints[1],\n        _lastPoints[2],\n        options,\n      );\n      const curve = Bezier.fromPoints(_lastPoints, widths);\n\n      // Remove the first element from the list, so that there are no more than 4 points at any time.\n      _lastPoints.shift();\n\n      return curve;\n    }\n\n    return null;\n  }\n\n  private _calculateCurveWidths(\n    startPoint: Point,\n    endPoint: Point,\n    options: PointGroupOptions,\n  ): { start: number; end: number } {\n    const velocity =\n      options.velocityFilterWeight * endPoint.velocityFrom(startPoint) +\n      (1 - options.velocityFilterWeight) * this._lastVelocity;\n\n    const newWidth = this._strokeWidth(velocity, options);\n\n    const widths = {\n      end: newWidth,\n      start: this._lastWidth,\n    };\n\n    this._lastVelocity = velocity;\n    this._lastWidth = newWidth;\n\n    return widths;\n  }\n\n  private _strokeWidth(velocity: number, options: PointGroupOptions): number {\n    return Math.max(options.maxWidth / (velocity + 1), options.minWidth);\n  }\n\n  private _drawCurveSegment(x: number, y: number, width: number): void {\n    const ctx = this._ctx;\n\n    ctx.moveTo(x, y);\n    ctx.arc(x, y, width, 0, 2 * Math.PI, false);\n    this._isEmpty = false;\n  }\n\n  private _drawCurve(curve: Bezier, options: PointGroupOptions): void {\n    const ctx = this._ctx;\n    const widthDelta = curve.endWidth - curve.startWidth;\n    // '2' is just an arbitrary number here. If only length is used, then\n    // there are gaps between curve segments :/\n    const drawSteps = Math.ceil(curve.length()) * 2;\n\n    ctx.beginPath();\n    ctx.fillStyle = options.penColor;\n\n    for (let i = 0; i < drawSteps; i += 1) {\n      // Calculate the Bezier (x, y) coordinate for this step.\n      const t = i / drawSteps;\n      const tt = t * t;\n      const ttt = tt * t;\n      const u = 1 - t;\n      const uu = u * u;\n      const uuu = uu * u;\n\n      let x = uuu * curve.startPoint.x;\n      x += 3 * uu * t * curve.control1.x;\n      x += 3 * u * tt * curve.control2.x;\n      x += ttt * curve.endPoint.x;\n\n      let y = uuu * curve.startPoint.y;\n      y += 3 * uu * t * curve.control1.y;\n      y += 3 * u * tt * curve.control2.y;\n      y += ttt * curve.endPoint.y;\n\n      const width = Math.min(\n        curve.startWidth + ttt * widthDelta,\n        options.maxWidth,\n      );\n      this._drawCurveSegment(x, y, width);\n    }\n\n    ctx.closePath();\n    ctx.fill();\n  }\n\n  private _drawDot(point: BasicPoint, options: PointGroupOptions): void {\n    const ctx = this._ctx;\n    const width =\n      options.dotSize > 0\n        ? options.dotSize\n        : (options.minWidth + options.maxWidth) / 2;\n\n    ctx.beginPath();\n    this._drawCurveSegment(point.x, point.y, width);\n    ctx.closePath();\n    ctx.fillStyle = options.penColor;\n    ctx.fill();\n  }\n\n  private _fromData(\n    pointGroups: PointGroup[],\n    drawCurve: SignaturePad['_drawCurve'],\n    drawDot: SignaturePad['_drawDot'],\n  ): void {\n    for (const group of pointGroups) {\n      const { points } = group;\n      const pointGroupOptions = this._getPointGroupOptions(group);\n\n      if (points.length > 1) {\n        for (let j = 0; j < points.length; j += 1) {\n          const basicPoint = points[j];\n          const point = new Point(\n            basicPoint.x,\n            basicPoint.y,\n            basicPoint.pressure,\n            basicPoint.time,\n          );\n\n          if (j === 0) {\n            this._reset(pointGroupOptions);\n          }\n\n          const curve = this._addPoint(point, pointGroupOptions);\n\n          if (curve) {\n            drawCurve(curve, pointGroupOptions);\n          }\n        }\n      } else {\n        this._reset(pointGroupOptions);\n\n        drawDot(points[0], pointGroupOptions);\n      }\n    }\n  }\n\n  public toSVG({ includeBackgroundColor = false }: ToSVGOptions = {}): string {\n    const pointGroups = this._data;\n    const ratio = Math.max(window.devicePixelRatio || 1, 1);\n    const minX = 0;\n    const minY = 0;\n    const maxX = this.canvas.width / ratio;\n    const maxY = this.canvas.height / ratio;\n    const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');\n\n    svg.setAttribute('xmlns', 'http://www.w3.org/2000/svg');\n    svg.setAttribute('xmlns:xlink', 'http://www.w3.org/1999/xlink');\n    svg.setAttribute('viewBox', `${minX} ${minY} ${maxX} ${maxY}`);\n    svg.setAttribute('width', maxX.toString());\n    svg.setAttribute('height', maxY.toString());\n\n    if (includeBackgroundColor && this.backgroundColor) {\n      const rect = document.createElement('rect');\n      rect.setAttribute('width', '100%');\n      rect.setAttribute('height', '100%');\n      rect.setAttribute('fill', this.backgroundColor);\n\n      svg.appendChild(rect);\n    }\n\n    this._fromData(\n      pointGroups,\n\n      (curve, { penColor }) => {\n        const path = document.createElement('path');\n\n        // Need to check curve for NaN values, these pop up when drawing\n        // lines on the canvas that are not continuous. E.g. Sharp corners\n        // or stopping mid-stroke and than continuing without lifting mouse.\n        if (\n          !isNaN(curve.control1.x) &&\n          !isNaN(curve.control1.y) &&\n          !isNaN(curve.control2.x) &&\n          !isNaN(curve.control2.y)\n        ) {\n          const attr =\n            `M ${curve.startPoint.x.toFixed(3)},${curve.startPoint.y.toFixed(\n              3,\n            )} ` +\n            `C ${curve.control1.x.toFixed(3)},${curve.control1.y.toFixed(3)} ` +\n            `${curve.control2.x.toFixed(3)},${curve.control2.y.toFixed(3)} ` +\n            `${curve.endPoint.x.toFixed(3)},${curve.endPoint.y.toFixed(3)}`;\n          path.setAttribute('d', attr);\n          path.setAttribute('stroke-width', (curve.endWidth * 2.25).toFixed(3));\n          path.setAttribute('stroke', penColor);\n          path.setAttribute('fill', 'none');\n          path.setAttribute('stroke-linecap', 'round');\n\n          svg.appendChild(path);\n        }\n      },\n\n      (point, { penColor, dotSize, minWidth, maxWidth }) => {\n        const circle = document.createElement('circle');\n        const size = dotSize > 0 ? dotSize : (minWidth + maxWidth) / 2;\n        circle.setAttribute('r', size.toString());\n        circle.setAttribute('cx', point.x.toString());\n        circle.setAttribute('cy', point.y.toString());\n        circle.setAttribute('fill', penColor);\n\n        svg.appendChild(circle);\n      },\n    );\n\n    return svg.outerHTML;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}